{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d3e43d9a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import torch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "a48aceb9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Transpose"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "dd524368",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Numpy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e57d8101",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# create a vector\n",
    "nv = np.array([ [1,2,3,4] ])\n",
    "print(nv), print(' ')\n",
    "\n",
    "# transpose it\n",
    "print(nv.T), print(' ')\n",
    "\n",
    "# transpose the transpose!\n",
    "nvT = nv.T\n",
    "print(nvT.T)\n",
    "     \n",
    "\n",
    "# repeat for a matrix\n",
    "nM = np.array([ [1,2,3,4],\n",
    "                [5,6,7,8] \n",
    "               ])\n",
    "print(nM), print(' ')\n",
    "\n",
    "# transpose it\n",
    "print(nM.T), print(' ')\n",
    "\n",
    "# transpose the transpose!\n",
    "nMT = nM.T\n",
    "print(nMT.T)\n",
    "     "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "9ff3a227",
   "metadata": {},
   "outputs": [],
   "source": [
    "# create a vector\n",
    "tv = torch.tensor([ [1,2,3,4] ])\n",
    "print(tv), print(' ')\n",
    "\n",
    "# transpose it\n",
    "print(tv.T), print(' ')\n",
    "\n",
    "# transpose the transpose!\n",
    "tvT = tv.T\n",
    "print(tvT.T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "fd0a4aed",
   "metadata": {},
   "outputs": [],
   "source": [
    "# repeat for a matrix\n",
    "tM = torch.tensor([ [1,2,3,4],[5,6,7,8] ])\n",
    "print(tM), print(' ')\n",
    "\n",
    "# transpose it\n",
    "print(tM.T), print(' ')\n",
    "\n",
    "# transpose the transpose!\n",
    "tMT = tM.T\n",
    "print(tMT.T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "6fd6c2d3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# examine data types\n",
    "print(f'Variable nv is of type {type(nv)}')\n",
    "print(f'Variable nM is of type {type(nM)}')\n",
    "print(f'Variable tv is of type {type(tv)}')\n",
    "print(f'Variable tM is of type {type(tM)}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "04b5866e",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "ea2c6cd4",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "$.getScript('https://kmahelona.github.io/ipython_notebook_goodies/ipython_notebook_toc.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "8dc95b83",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "3886eec6",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "5e439e2c",
   "metadata": {},
   "outputs": [],
   "source": [
    "<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>\n",
    "%%javascript\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "5445da0f",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "ca5cc646",
   "metadata": {},
   "outputs": [],
   "source": [
    "<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>\n",
    "%%javascript\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "1322b748",
   "metadata": {},
   "outputs": [],
   "source": [
    "<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "d63ab602",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "$.getScript('https://lopezishere.github.io/jupyter_ToC/jupyter_ToC.js')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "c7bbc9c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "// Builds a <ul> Table of Contents from all <headers> in DOM\n",
    "function createTOC(){\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {}\n",
    "    $('#toc').html('');\n",
    "\n",
    "    $(\":header\").each(function(i){\n",
    "\t    if (this.id=='tocheading'){return;}\n",
    "        \n",
    "\t    titleText = this.innerHTML;\n",
    "\t    openLevel = this.tagName[1];\n",
    "\n",
    "\t    if (levels[openLevel]){\n",
    "\t\tlevels[openLevel] += 1;\n",
    "\t    } else{\n",
    "\t\tlevels[openLevel] = 1;\n",
    "\t    }\n",
    "\n",
    "\t    if (openLevel > level) {\n",
    "\t\ttoc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "\t    } else if (openLevel < level) {\n",
    "\t\ttoc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "\t\tfor (i=level;i>openLevel;i--){levels[i]=0;}\n",
    "\t    }\n",
    "\n",
    "\t    level = parseInt(openLevel);\n",
    "\n",
    "\n",
    "\t    if (this.id==''){this.id = this.innerHTML.replace(/ /g,\"-\")}\n",
    "\t    var anchor = this.id;\n",
    "        \n",
    "\t    toc += '<li><a href=\"#' + anchor + '\">' + titleText\n",
    "\t\t+ '</a></li>';\n",
    "        \n",
    "\t});\n",
    "\n",
    "    \n",
    "    if (level) {\n",
    "\ttoc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    " \n",
    "    $('#toc').append(toc);\n",
    "\n",
    "};\n",
    "\n",
    "// Executes the createToc function\n",
    "setTimeout(function(){createTOC();},100);\n",
    "\n",
    "// Rebuild to TOC every minute\n",
    "setInterval(function(){createTOC();},60000);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "4e77642d",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "// Builds a <ul> Table of Contents from all <headers> in DOM\n",
    "function createTOC(){\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {}\n",
    "    $('#toc').html('');\n",
    "\n",
    "    $(\":header\").each(function(i){\n",
    "\t    if (this.id=='tocheading'){return;}\n",
    "        \n",
    "\t    titleText = this.innerHTML;\n",
    "\t    openLevel = this.tagName[1];\n",
    "\n",
    "\t    if (levels[openLevel]){\n",
    "\t\tlevels[openLevel] += 1;\n",
    "\t    } else{\n",
    "\t\tlevels[openLevel] = 1;\n",
    "\t    }\n",
    "\n",
    "\t    if (openLevel > level) {\n",
    "\t\ttoc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "\t    } else if (openLevel < level) {\n",
    "\t\ttoc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "\t\tfor (i=level;i>openLevel;i--){levels[i]=0;}\n",
    "\t    }\n",
    "\n",
    "\t    level = parseInt(openLevel);\n",
    "\n",
    "\n",
    "\t    if (this.id==''){this.id = this.innerHTML.replace(/ /g,\"-\")}\n",
    "\t    var anchor = this.id;\n",
    "        \n",
    "\t    toc += '<li><a href=\"#' + anchor + '\">' + titleText\n",
    "\t\t+ '</a></li>';\n",
    "        \n",
    "\t});\n",
    "\n",
    "    \n",
    "    if (level) {\n",
    "\ttoc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    " \n",
    "    $('#toc').append(toc);\n",
    "\n",
    "};\n",
    "\n",
    "// Executes the createToc function\n",
    "setTimeout(function(){createTOC();},100);\n",
    "\n",
    "// Rebuild to TOC every minute\n",
    "setInterval(function(){createTOC();},60000);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "55632c98",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "// Builds a <ul> Table of Contents from all <headers> in DOM\n",
    "function createTOC(){\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {}\n",
    "    $('#toc').html('');\n",
    "\n",
    "    $(\":header\").each(function(i){\n",
    "\t    if (this.id=='tocheading'){return;}\n",
    "        \n",
    "\t    titleText = this.innerHTML;\n",
    "\t    openLevel = this.tagName[1];\n",
    "\n",
    "\t    if (levels[openLevel]){\n",
    "\t\tlevels[openLevel] += 1;\n",
    "\t    } else{\n",
    "\t\tlevels[openLevel] = 1;\n",
    "\t    }\n",
    "\n",
    "\t    if (openLevel > level) {\n",
    "\t\ttoc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "\t    } else if (openLevel < level) {\n",
    "\t\ttoc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "\t\tfor (i=level;i>openLevel;i--){levels[i]=0;}\n",
    "\t    }\n",
    "\n",
    "\t    level = parseInt(openLevel);\n",
    "\n",
    "\n",
    "\t    if (this.id==''){this.id = this.innerHTML.replace(/ /g,\"-\")}\n",
    "\t    var anchor = this.id;\n",
    "        \n",
    "\t    toc += '<li><a href=\"#' + anchor + '\">' + titleText\n",
    "\t\t+ '</a></li>';\n",
    "        \n",
    "\t});\n",
    "\n",
    "    \n",
    "    if (level) {\n",
    "\ttoc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    " \n",
    "    $('#toc').append(toc);\n",
    "\n",
    "};\n",
    "\n",
    "// Executes the createToc function\n",
    "setTimeout(function(){createTOC();},100);\n",
    "\n",
    "// Rebuild to TOC every minute\n",
    "setInterval(function(){createTOC();},60000);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "21bc842b",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "// Builds a <ul> Table of Contents from all <headers> in DOM\n",
    "function createTOC(){\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {}\n",
    "    $('#toc').html('');\n",
    "\n",
    "    $(\":header\").each(function(i){\n",
    "\t    if (this.id=='tocheading'){return;}\n",
    "        \n",
    "\t    titleText = this.innerHTML;\n",
    "\t    openLevel = this.tagName[1];\n",
    "\n",
    "\t    if (levels[openLevel]){\n",
    "\t\tlevels[openLevel] += 1;\n",
    "\t    } else{\n",
    "\t\tlevels[openLevel] = 1;\n",
    "\t    }\n",
    "\n",
    "\t    if (openLevel > level) {\n",
    "\t\ttoc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "\t    } else if (openLevel < level) {\n",
    "\t\ttoc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "\t\tfor (i=level;i>openLevel;i--){levels[i]=0;}\n",
    "\t    }\n",
    "\n",
    "\t    level = parseInt(openLevel);\n",
    "\n",
    "\n",
    "\t    if (this.id==''){this.id = this.innerHTML.replace(/ /g,\"-\")}\n",
    "\t    var anchor = this.id;\n",
    "        \n",
    "\t    toc += '<li><a href=\"#' + anchor + '\">' + titleText\n",
    "\t\t+ '</a></li>';\n",
    "        \n",
    "\t});\n",
    "\n",
    "    \n",
    "    if (level) {\n",
    "\ttoc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    " \n",
    "    $('#toc').append(toc);\n",
    "\n",
    "};\n",
    "\n",
    "// Executes the createToc function\n",
    "setTimeout(function(){createTOC();},100);\n",
    "\n",
    "// Rebuild to TOC every minute\n",
    "setInterval(function(){createTOC();},60000);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "ee805b7e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_toc_cell():\n",
    "    from IPython.display import display, Markdown\n",
    "    from notebook import notebookapp\n",
    "    import json\n",
    "    import os\n",
    "\n",
    "    # Function to generate TOC cell\n",
    "    def generate_toc():\n",
    "        nb = None\n",
    "        for server in notebookapp.list_running_servers():\n",
    "            if server['token'] == '':\n",
    "                url = f\"http://localhost:{server['port']}/notebooks/{server['base_url']}\"\n",
    "            else:\n",
    "                url = f\"http://localhost:{server['port']}/notebooks/{server['base_url']}?token={server['token']}\"\n",
    "\n",
    "            try:\n",
    "                response = os.popen(f\"jupyter nbconvert --to notebook --output - '{url}'\").read()\n",
    "                nb = json.loads(response)\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "        if nb:\n",
    "            toc = []\n",
    "            for cell in nb['cells']:\n",
    "                if cell['cell_type'] == 'markdown' and cell['source'].strip().lower().startswith(\"#\"):\n",
    "                    title = cell['source'].strip().replace('#', '').strip()\n",
    "                    level = cell['source'].strip().count('#')\n",
    "                    toc.append(\"  \" * (level - 1) + f\"* [{title}](#{title.lower().replace(' ', '-')})\")\n",
    "\n",
    "            toc_md = \"\\n\".join(toc)\n",
    "            toc_cell = f\"## Table of Contents\\n{toc_md}\"\n",
    "\n",
    "            return toc_cell\n",
    "\n",
    "        else:\n",
    "            return None\n",
    "\n",
    "    toc_cell = generate_toc()\n",
    "\n",
    "    if toc_cell:\n",
    "        display(Markdown(toc_cell))\n",
    "    else:\n",
    "        print(\"Failed to generate TOC cell.\")\n",
    "\n",
    "create_toc_cell()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "d4d83773",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_toc_cell():\n",
    "    from IPython.display import display, Markdown\n",
    "    import nbformat\n",
    "    import os\n",
    "\n",
    "    # Function to generate TOC cell\n",
    "    def generate_toc():\n",
    "        nb = None\n",
    "        with open(os.getenv(\"JUPYTER_NOTEBOOK\", \"\"), \"r\", encoding=\"utf-8\") as f:\n",
    "            nb = nbformat.read(f, as_version=4)\n",
    "\n",
    "        if nb:\n",
    "            toc = []\n",
    "            for cell in nb.cells:\n",
    "                if cell.cell_type == 'markdown' and cell.source.strip().lower().startswith(\"#\"):\n",
    "                    title = cell.source.strip().replace('#', '').strip()\n",
    "                    level = cell.source.strip().count('#')\n",
    "                    toc.append(\"  \" * (level - 1) + f\"* [{title}](#{title.lower().replace(' ', '-')})\")\n",
    "\n",
    "            toc_md = \"\\n\".join(toc)\n",
    "            toc_cell = f\"## Table of Contents\\n{toc_md}\"\n",
    "\n",
    "            return toc_cell\n",
    "\n",
    "        else:\n",
    "            return None\n",
    "\n",
    "    toc_cell = generate_toc()\n",
    "\n",
    "    if toc_cell:\n",
    "        display(Markdown(toc_cell))\n",
    "    else:\n",
    "        print(\"Failed to generate TOC cell.\")\n",
    "\n",
    "create_toc_cell()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "d46846e6",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_toc_cell():\n",
    "    from IPython.display import display, Markdown\n",
    "    import nbformat\n",
    "\n",
    "    # Function to generate TOC cell\n",
    "    def generate_toc():\n",
    "        nb = None\n",
    "        try:\n",
    "            nb = nbformat.reads(get_ipython().run_line_magic('notebook', 'json'), as_version=4)\n",
    "        except Exception as e:\n",
    "            print(\"Error reading notebook:\", e)\n",
    "            return None\n",
    "\n",
    "        if nb:\n",
    "            toc = []\n",
    "            for cell in nb['cells']:\n",
    "                if cell['cell_type'] == 'markdown' and cell['source'].strip().lower().startswith(\"#\"):\n",
    "                    title = cell['source'].strip().replace('#', '').strip()\n",
    "                    level = cell['source'].strip().count('#')\n",
    "                    toc.append(\"  \" * (level - 1) + f\"* [{title}](#{title.lower().replace(' ', '-')})\")\n",
    "\n",
    "            toc_md = \"\\n\".join(toc)\n",
    "            toc_cell = f\"## Table of Contents\\n{toc_md}\"\n",
    "\n",
    "            return toc_cell\n",
    "\n",
    "        else:\n",
    "            return None\n",
    "\n",
    "    toc_cell = generate_toc()\n",
    "\n",
    "    if toc_cell:\n",
    "        display(Markdown(toc_cell))\n",
    "    else:\n",
    "        print(\"Failed to generate TOC cell.\")\n",
    "\n",
    "create_toc_cell()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "775d0d8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_toc_cell():\n",
    "    from IPython.display import display, Markdown\n",
    "    import nbformat\n",
    "\n",
    "    # Function to generate TOC cell\n",
    "    def generate_toc():\n",
    "        notebook_json = get_ipython().run_line_magic('notebook', 'json')\n",
    "        if not notebook_json:\n",
    "            print(\"Error: Unable to retrieve notebook JSON.\")\n",
    "            return None\n",
    "        \n",
    "        try:\n",
    "            nb = nbformat.reads(notebook_json, as_version=4)\n",
    "        except Exception as e:\n",
    "            print(\"Error reading notebook:\", e)\n",
    "            return None\n",
    "\n",
    "        if nb:\n",
    "            toc = []\n",
    "            for cell in nb['cells']:\n",
    "                if cell['cell_type'] == 'markdown' and cell['source'].strip().lower().startswith(\"#\"):\n",
    "                    title = cell['source'].strip().replace('#', '').strip()\n",
    "                    level = cell['source'].strip().count('#')\n",
    "                    toc.append(\"  \" * (level - 1) + f\"* [{title}](#{title.lower().replace(' ', '-')})\")\n",
    "\n",
    "            toc_md = \"\\n\".join(toc)\n",
    "            toc_cell = f\"## Table of Contents\\n{toc_md}\"\n",
    "\n",
    "            return toc_cell\n",
    "\n",
    "        else:\n",
    "            return None\n",
    "\n",
    "    toc_cell = generate_toc()\n",
    "\n",
    "    if toc_cell:\n",
    "        display(Markdown(toc_cell))\n",
    "    else:\n",
    "        print(\"Failed to generate TOC cell.\")\n",
    "\n",
    "create_toc_cell()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "596c5c35",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "function createTOC() {\n",
    "    // Function to generate TOC cell\n",
    "    function generateTOC() {\n",
    "        var toc = [];\n",
    "        var notebookCells = Jupyter.notebook.get_cells();\n",
    "        \n",
    "        for (var i = 0; i < notebookCells.length; i++) {\n",
    "            var cell = notebookCells[i];\n",
    "            if (cell.cell_type == 'markdown' && cell.get_text().trim().startsWith(\"#\")) {\n",
    "                var title = cell.get_text().trim().replace('#', '').trim();\n",
    "                var level = (cell.get_text().match(/#/g) || []).length;\n",
    "                toc.push(\"  \".repeat(level - 1) + \"* [\" + title + \"](#\" + title.toLowerCase().replace(/\\s+/g, '-') + \")\");\n",
    "            }\n",
    "        }\n",
    "        \n",
    "        var tocMarkdown = \"## Table of Contents\\n\" + toc.join(\"\\n\");\n",
    "        return tocMarkdown;\n",
    "    }\n",
    "    \n",
    "    var tocMarkdown = generateTOC();\n",
    "    if (tocMarkdown) {\n",
    "        var tocCell = Jupyter.notebook.insert_cell_above('markdown');\n",
    "        tocCell.set_text(tocMarkdown);\n",
    "        tocCell.render();\n",
    "    } else {\n",
    "        console.log(\"Failed to generate TOC cell.\");\n",
    "    }\n",
    "}\n",
    "\n",
    "createTOC();"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "9ec66d7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "// Function to generate TOC cell\n",
    "function generateTOC() {\n",
    "    var toc = [];\n",
    "    var notebookCells = Jupyter.notebook.get_cells();\n",
    "    \n",
    "    for (var i = 0; i < notebookCells.length; i++) {\n",
    "        var cell = notebookCells[i];\n",
    "        if (cell.cell_type == 'markdown' && cell.get_text().trim().startsWith(\"#\")) {\n",
    "            var title = cell.get_text().trim().replace('#', '').trim();\n",
    "            var level = (cell.get_text().match(/#/g) || []).length;\n",
    "            toc.push(\"  \".repeat(level - 1) + \"* [\" + title + \"](#\" + title.toLowerCase().replace(/\\s+/g, '-') + \")\");\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    var tocMarkdown = \"## Table of Contents\\n\" + toc.join(\"\\n\");\n",
    "    return tocMarkdown;\n",
    "}\n",
    "\n",
    "var tocMarkdown = generateTOC();\n",
    "if (tocMarkdown) {\n",
    "    var currentIndex = Jupyter.notebook.get_selected_index();\n",
    "    var tocCell = Jupyter.notebook.insert_cell_above('markdown');\n",
    "    tocCell.set_text(tocMarkdown);\n",
    "    Jupyter.notebook.select(currentIndex); // Retain selection\n",
    "    tocCell.render();\n",
    "} else {\n",
    "    console.log(\"Failed to generate TOC cell.\");\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "763fc45c",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "// Function to generate TOC cell\n",
    "function generateTOC() {\n",
    "    var toc = [];\n",
    "    var notebookCells = Jupyter.notebook.get_cells();\n",
    "    \n",
    "    for (var i = 0; i < notebookCells.length; i++) {\n",
    "        var cell = notebookCells[i];\n",
    "        if (cell.cell_type == 'markdown' && cell.get_text().trim().startsWith(\"#\")) {\n",
    "            var title = cell.get_text().trim().replace('#', '').trim();\n",
    "            var level = (cell.get_text().match(/#/g) || []).length;\n",
    "            toc.push(\"  \".repeat(level - 1) + \"* [\" + title + \"](#\" + title.toLowerCase().replace(/\\s+/g, '-') + \")\");\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    var tocMarkdown = \"## Table of Contents\\n\" + toc.join(\"\\n\");\n",
    "    return tocMarkdown;\n",
    "}\n",
    "\n",
    "var tocMarkdown = generateTOC();\n",
    "if (tocMarkdown) {\n",
    "    var currentIndex = Jupyter.notebook.get_selected_index();\n",
    "    var tocCell = Jupyter.notebook.insert_cell_above('markdown');\n",
    "    tocCell.set_text(tocMarkdown);\n",
    "    Jupyter.notebook.select(currentIndex); // Retain selection\n",
    "    tocCell.render();\n",
    "} else {\n",
    "    console.log(\"Failed to generate TOC cell.\");\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "3e1c8165",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "// Function to generate TOC cell\n",
    "function generateTOC() {\n",
    "    var toc = [];\n",
    "    var notebookCells = Jupyter.notebook.get_cells();\n",
    "    \n",
    "    for (var i = 0; i < notebookCells.length; i++) {\n",
    "        var cell = notebookCells[i];\n",
    "        if (cell.cell_type == 'markdown' && cell.get_text().trim().startsWith(\"#\")) {\n",
    "            var title = cell.get_text().trim().replace('#', '').trim();\n",
    "            var level = (cell.get_text().match(/#/g) || []).length;\n",
    "            toc.push(\"  \".repeat(level - 1) + \"* [\" + title + \"](#\" + title.toLowerCase().replace(/\\s+/g, '-') + \")\");\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    var tocMarkdown = \"## Table of Contents\\n\" + toc.join(\"\\n\");\n",
    "    return tocMarkdown;\n",
    "}\n",
    "\n",
    "var tocMarkdown = generateTOC();\n",
    "if (tocMarkdown) {\n",
    "    var currentIndex = Jupyter.notebook.get_selected_index();\n",
    "    var tocCell = Jupyter.notebook.insert_cell_above('markdown');\n",
    "    tocCell.set_text(tocMarkdown);\n",
    "    Jupyter.notebook.select(currentIndex); // Retain selection\n",
    "    tocCell.render();\n",
    "} else {\n",
    "    console.log(\"Failed to generate TOC cell.\");\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "9bd34d42",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "// Function to create Table of Contents (TOC) in Jupyter Notebook\n",
    "function createTOC() {\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {};\n",
    "    var notebookCells = Jupyter.notebook.get_cells();\n",
    "\n",
    "    // Clear existing TOC content\n",
    "    $('#toc').html('');\n",
    "\n",
    "    // Iterate through all cells in the notebook\n",
    "    for (var i = 0; i < notebookCells.length; i++) {\n",
    "        var cell = notebookCells[i];\n",
    "\n",
    "        // Check if the cell is a markdown cell and contains a header\n",
    "        if (cell.cell_type === 'markdown' && cell.element.find(':header').length > 0) {\n",
    "            cell.element.find(':header').each(function() {\n",
    "                var header = $(this);\n",
    "                var titleText = header.text();\n",
    "                var openLevel = header[0].tagName[1];\n",
    "\n",
    "                // Update levels count\n",
    "                if (levels[openLevel]) {\n",
    "                    levels[openLevel] += 1;\n",
    "                } else {\n",
    "                    levels[openLevel] = 1;\n",
    "                }\n",
    "\n",
    "                // Add appropriate indentation for nested levels\n",
    "                if (openLevel > level) {\n",
    "                    toc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "                } else if (openLevel < level) {\n",
    "                    toc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "                    for (var j = level; j > openLevel; j--) {\n",
    "                        levels[j] = 0;\n",
    "                    }\n",
    "                }\n",
    "\n",
    "                level = parseInt(openLevel);\n",
    "\n",
    "                // Generate anchor link for header\n",
    "                var anchor = header.attr('id') || header.text().replace(/ /g, \"-\").toLowerCase();\n",
    "\n",
    "                // Append TOC entry\n",
    "                toc += '<li><a href=\"#' + anchor + '\">' + titleText + '</a></li>';\n",
    "            });\n",
    "        }\n",
    "    }\n",
    "\n",
    "    // Close any remaining unordered lists\n",
    "    if (level) {\n",
    "        toc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    "    // Append TOC to the specified container\n",
    "    $('#toc').append(toc);\n",
    "}\n",
    "\n",
    "// Execute the createTOC function\n",
    "setTimeout(function() {\n",
    "    createTOC();\n",
    "}, 100);\n",
    "\n",
    "// Rebuild TOC every minute\n",
    "setInterval(function() {\n",
    "    createTOC();\n",
    "}, 60000);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "95e12983",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "// Function to create Table of Contents (TOC) in Jupyter Notebook\n",
    "function createTOC() {\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {};\n",
    "    var notebookCells = Jupyter.notebook.get_cells();\n",
    "\n",
    "    // Clear existing TOC content\n",
    "    $('#toc').html('');\n",
    "\n",
    "    // Iterate through all cells in the notebook\n",
    "    for (var i = 0; i < notebookCells.length; i++) {\n",
    "        var cell = notebookCells[i];\n",
    "\n",
    "        // Check if the cell is a markdown cell and contains a header\n",
    "        if (cell.cell_type === 'markdown' && cell.element.find(':header').length > 0) {\n",
    "            cell.element.find(':header').each(function() {\n",
    "                var header = $(this);\n",
    "                var titleText = header.text();\n",
    "                var openLevel = header[0].tagName[1];\n",
    "\n",
    "                // Update levels count\n",
    "                if (levels[openLevel]) {\n",
    "                    levels[openLevel] += 1;\n",
    "                } else {\n",
    "                    levels[openLevel] = 1;\n",
    "                }\n",
    "\n",
    "                // Add appropriate indentation for nested levels\n",
    "                if (openLevel > level) {\n",
    "                    toc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "                } else if (openLevel < level) {\n",
    "                    toc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "                    for (var j = level; j > openLevel; j--) {\n",
    "                        levels[j] = 0;\n",
    "                    }\n",
    "                }\n",
    "\n",
    "                level = parseInt(openLevel);\n",
    "\n",
    "                // Generate anchor link for header\n",
    "                var anchor = header.attr('id') || header.text().replace(/ /g, \"-\").toLowerCase();\n",
    "\n",
    "                // Append TOC entry\n",
    "                toc += '<li><a href=\"#' + anchor + '\">' + titleText + '</a></li>';\n",
    "            });\n",
    "        }\n",
    "    }\n",
    "\n",
    "    // Close any remaining unordered lists\n",
    "    if (level) {\n",
    "        toc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    "    // Append TOC to the specified container\n",
    "    $('#toc').append(toc);\n",
    "}\n",
    "\n",
    "// Execute the createTOC function\n",
    "setTimeout(function() {\n",
    "    createTOC();\n",
    "}, 100);\n",
    "\n",
    "// Rebuild TOC every minute\n",
    "setInterval(function() {\n",
    "    createTOC();\n",
    "}, 60000);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "b10556a1",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%javascript\n",
    "\n",
    "// Function to create Table of Contents (TOC) in Jupyter Notebook\n",
    "function createTOC() {\n",
    "    var toc = \"\";\n",
    "    var level = 0;\n",
    "    var levels = {};\n",
    "    var notebookCells = Jupyter.notebook.get_cells();\n",
    "\n",
    "    // Clear existing TOC content\n",
    "    $('#toc').html('');\n",
    "\n",
    "    // Iterate through all cells in the notebook\n",
    "    for (var i = 0; i < notebookCells.length; i++) {\n",
    "        var cell = notebookCells[i];\n",
    "\n",
    "        // Check if the cell is a markdown cell and contains a header\n",
    "        if (cell.cell_type === 'markdown' && cell.element.find(':header').length > 0) {\n",
    "            cell.element.find(':header').each(function() {\n",
    "                var header = $(this);\n",
    "                var titleText = header.text();\n",
    "                var openLevel = header[0].tagName[1];\n",
    "\n",
    "                // Update levels count\n",
    "                if (levels[openLevel]) {\n",
    "                    levels[openLevel] += 1;\n",
    "                } else {\n",
    "                    levels[openLevel] = 1;\n",
    "                }\n",
    "\n",
    "                // Add appropriate indentation for nested levels\n",
    "                if (openLevel > level) {\n",
    "                    toc += (new Array(openLevel - level + 1)).join('<ul class=\"toc\">');\n",
    "                } else if (openLevel < level) {\n",
    "                    toc += (new Array(level - openLevel + 1)).join(\"</ul>\");\n",
    "                    for (var j = level; j > openLevel; j--) {\n",
    "                        levels[j] = 0;\n",
    "                    }\n",
    "                }\n",
    "\n",
    "                level = parseInt(openLevel);\n",
    "\n",
    "                // Generate anchor link for header\n",
    "                var anchor = header.attr('id') || header.text().replace(/ /g, \"-\").toLowerCase();\n",
    "\n",
    "                // Append TOC entry\n",
    "                toc += '<li><a href=\"#' + anchor + '\">' + titleText + '</a></li>';\n",
    "            });\n",
    "        }\n",
    "    }\n",
    "\n",
    "    // Close any remaining unordered lists\n",
    "    if (level) {\n",
    "        toc += (new Array(level + 1)).join(\"</ul>\");\n",
    "    }\n",
    "\n",
    "    // Append TOC to the specified container\n",
    "    $('#toc').append(toc);\n",
    "}\n",
    "\n",
    "createTOC();"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "5c52a19a",
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install ipympl"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "2c3e049f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"## Table of Contents\\n\\n\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^#{1,6} .+$', content, flags=re.MULTILINE)\n",
    "        for header in headers:\n",
    "            header_level = header.count('#')\n",
    "            header_text = header.strip('#').strip()\n",
    "            toc += f\"{'  '*(header_level-1)}- [{header_text}](#{header_text.lower().replace(' ', '-')})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('your_notebook.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "b5ccc639",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"## Table of Contents\\n\\n\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^#{1,6} .+$', content, flags=re.MULTILINE)\n",
    "        for header in headers:\n",
    "            header_level = header.count('#')\n",
    "            header_text = header.strip('#').strip()\n",
    "            toc += f\"{'  '*(header_level-1)}- [{header_text}](#{header_text.lower().replace(' ', '-')})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_Learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "30c7e14f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"## Table of Contents\\n\\n\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^#{1,6} .+$', content, flags=re.MULTILINE)\n",
    "        for header in headers:\n",
    "            header_level = header.count('#')\n",
    "            header_text = header.strip('#').strip()\n",
    "            toc += f\"{'  '*(header_level-1)}- [{header_text}](#{header_text.lower().replace(' ', '-')})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_Learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "5cdbeb85",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"## Table of Contents\\n\\n\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^#{1,6} .+$', content, flags=re.MULTILINE)\n",
    "        for header in headers:\n",
    "            header_level = header.count('#')\n",
    "            header_text = header.strip('#').strip()\n",
    "            toc += f\"{'  '*(header_level-1)}- [{header_text}](#{header_text.lower().replace(' ', '-')})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_Learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "2ab6d136",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^#{1,6} .+$', content, flags=re.MULTILINE)\n",
    "        for header in headers:\n",
    "            header_level = header.count('#')\n",
    "            header_text = header.strip('#').strip()\n",
    "            toc += f\"{'  '*(header_level-1)}- [{header_text}](#{header_text.lower().replace(' ', '-')})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "edf7dbcc",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^#{1,6} .+$', content, flags=re.MULTILINE)\n",
    "        for header in headers:\n",
    "            header_level = header.count('#')\n",
    "            header_text = header.strip('#').strip()\n",
    "            toc += f\"{'  '*(header_level-1)}- [{header_text}](#{header_text.lower().replace(' ', '-')})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "c4877e5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^(#+)\\s+(.*)$', content, flags=re.MULTILINE)\n",
    "        for header_level, header_text in headers:\n",
    "            header_level = len(header_level)\n",
    "            header_text = header_text.strip()\n",
    "            toc += f\"{'  ' * (header_level - 1)}- [{' '.join(header_text.splitlines())}](#{'-'.join(header_text.lower().split())})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_Learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "cf7841de",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def generate_toc(notebook_path):\n",
    "    toc = \"\"\n",
    "    with open(notebook_path, 'r', encoding='utf-8') as f:\n",
    "        content = f.read()\n",
    "        headers = re.findall(r'^(#+)\\s+(.*)$', content, flags=re.MULTILINE)\n",
    "        for header_level, header_text in headers:\n",
    "            header_level = len(header_level)\n",
    "            header_text = header_text.strip()\n",
    "            toc += f\"{'  ' * (header_level - 1)}- [{' '.join(header_text.splitlines())}](#{'-'.join(header_text.lower().split())})\\n\"\n",
    "    return toc\n",
    "\n",
    "# Replace 'your_notebook.ipynb' with your notebook file path\n",
    "toc = generate_toc('Deep_Learning.ipynb')\n",
    "\n",
    "# Print or save the generated TOC\n",
    "print(toc)"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
